//Bleed Out Mechanic Shared by several game modes.
/*
WARNING BY NESSIE: Bleedout_DiableWallrunAndDoubleJump() and Bleedout_EnableWallrunAndDoubleJump()
existing, which will do a "OnClassChange" after being downed or revived, please notice!
maybe when bleeding player is wallrunning we FreezeControl could be better? like SlidePrevention()
*/
global function Bleedout_Init
global function Bleedout_StartPlayerBleedout
global function Bleedout_AddCallback_OnPlayerStartBleedout
global function Bleedout_AddCallback_OnPlayerGiveFirstAid
global function Bleedout_ShouldAIMissBleedingPlayer

const asset FX_BLOODTRAIL = $"skit_blood_decal_LG"
const float BLEEDOUT_MAX_USE_DIST2_MOD = 64 * 64

// modified function
global function Bleedout_EnableExecutingBleeingPlayer

global function Bleedout_IsPlayerSelfHealing
global function Bleedout_IsPlayerGettingFirstAid

global function Bleedout_IsPlayerBleeding
//global function Bleedout_IsRevivingFriendly // no idea how to make it

global function Bleedout_HealthRegenThink
global function Bleedout_SetHealthRegenRate

const bool BLEEDOUT_DEBUG = false
const BLEEDOUT_EXECUTION_HITBOX_MODEL = $"models/weapons/bullets/mgl_grenade.mdl"

struct
{
	table<entity,bool> isBleeding
	table<entity, entity> IsGettingFirstAidFrom
	table<entity, entity> lastAttacker
	// victim, attacker, damageInfo
	array<void functionref( entity, entity, var )> Callbacks_OnPlayerStartBleedout 
	// playerToRes, playerHealer
	array<void functionref( entity, entity )> Callbacks_OnPlayerGiveFirstAid 
	int firstAidAttemptID = 0 //The ID that identifies the first aid attempt. Used to distinguish between simultainous healing attempts on the client

	// modified variable
	bool executingBleedingEnabled = false
	float bleedoutHealthRegenRate = 4.0
	float bleedoutHealthRegenDelay = 4.0
	table<entity, string> playerSavedTitle
} file

void function Bleedout_Init()
{
	RegisterSignal( "BleedOut_StopBleeding" )
	RegisterSignal( "BleedOut_OnRevive" )
	RegisterSignal( "BleedOut_OnStartDying" )
	RegisterSignal( "OnContinousUseStopped" )

	// modifed signal
	RegisterSignal( "BleedoutHealthRegenThink" )
	RegisterSignal( "Bleedout_PlayerAttemptRes" )
	RegisterSignal( "Bleedout_OnStartReviving" )

	AddCallback_OnClientConnected( Bleedout_OnClientConnected )
	AddCallback_OnClientDisconnected( Bleedout_OnClientDisconnected )

	PrecacheParticleSystem( FX_BLOODTRAIL )
}

void function Bleedout_OnClientConnected( entity player )
{
	file.isBleeding[ player ] <- false
	file.IsGettingFirstAidFrom[ player ] <- null
	file.lastAttacker[ player ] <- svGlobal.worldspawn
	file.playerSavedTitle[ player ] <- ""
}

void function Bleedout_OnClientDisconnected( entity player )
{
	/* unhandled delete, no need for now
	delete file.isBleeding[ player ]
	delete file.IsGettingFirstAidFrom[ player ]
	delete file.lastAttacker[ player ]
	delete file.playerSavedTitle[ player ]
	*/
}

void function Bleedout_AddCallback_OnPlayerStartBleedout( void functionref(entity, entity, var) callback )
{
	file.Callbacks_OnPlayerStartBleedout.append( callback )
}

void function Bleedout_AddCallback_OnPlayerGiveFirstAid( void functionref(entity, entity) callback )
{
	file.Callbacks_OnPlayerGiveFirstAid.append( callback )
}

void function Bleedout_StartPlayerBleedout( entity player, entity attacker, var damageInfo ) // victim, attacker, damageInfo
{
	//if the player is already bleeding don't restart bleeding logic.
	if ( file.isBleeding[ player ] )
		return

	player.Signal( "BleedOut_StopBleeding" )
	player.Signal( "BleedOut_OnStartDying" )

	file.lastAttacker[ player ] = attacker

	if ( Bleedout_GetDeathOnTeamBleedout() )
	{
		bool isLastPlayer = CheckForTeamBleedout( player )
		if( isLastPlayer )
		{
			// player will just die
			//player.Die( DamageInfo_GetAttacker( damageInfo ), DamageInfo_GetAttacker( damageInfo ), { damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo ) } )
			return
		}
	}
	
	Bleedout_PlayerDownedSound( player, attacker )
	Bleedout_PlayerDownedObit( player, attacker, damageInfo )

	// this should done before callbacks since it triggers a "OnClassChange"
	Bleedout_DiableWallrunAndDoubleJump( player ) 

	EmitSoundOnEntityToTeam( player, "UI_Spawn_FriendlyPilot", player.GetTeam() )
	foreach( void functionref( entity, entity, var ) callbackFunc in file.Callbacks_OnPlayerStartBleedout )
	{
		//if ( IsValid( callbackFunc ) && !file.isBleeding[ player ] )
			//callbackFunc( player )
		callbackFunc( player, attacker, damageInfo )
	}

	thread Bleedout_DeathProtection( player )

	thread BloodTrail( player )
	thread PlayerDying( player )
	thread EnablePlayerRes( player )

	//Start selfhealing thread if enabled.
	if ( Bleedout_GetSelfResEnabled() )
		thread EnablePlayerSelfRes( player )

	// nessie mix, better support for killshot sounds
	//if ( Bleedout_GetDeathOnTeamBleedout() )
	//	CheckForTeamBleedout( player.GetTeam() )
}

void function PlayerDying( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_OnRevive" )
	player.EndSignal( "BleedOut_OnStartDying" )

	float bleedoutTime = Bleedout_GetBleedoutTime()
	bool forceHolster = Bleedout_GetForceWeaponHolster()

	array<int> ids = []
	ids.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.25 ) )
	ids.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )

	//if ( bleedoutTime > 0 )
	//	ids.append( StatusEffect_AddEndless( player, eStatusEffect.bleedoutDOF, 1.0 ) )

	file.isBleeding[ player ] = true

	player.ForceCrouch()
	string playerTitle = player.GetTitle()
	if( playerTitle != "#DEATH_BLEEDOUT" )
		file.playerSavedTitle[player] = playerTitle
	player.SetTitle( "#DEATH_BLEEDOUT" )
	player.SetOneHandedWeaponUsageOn()
	thread Bleedout_PlayerSlidePrevention( player )
	thread Bleedout_EnemySpottingHighlight( player )

	if ( forceHolster )
	{
		//HolsterAndDisableWeapons( player )
		thread Bleedout_PlayerHolsterWeapon( player ) // better fix
	}

	OnThreadEnd(
	function() : ( player, ids, forceHolster, playerTitle )
		{
			if ( IsValid( player ) )
			{
				foreach ( id in ids )
					StatusEffect_Stop( player, id )

				file.isBleeding[ player ] = false
				file.lastAttacker[ player ] = svGlobal.worldspawn

				player.UnforceCrouch()
				thread Bleedout_PlayerForceStand( player )
				player.SetTitle( file.playerSavedTitle[player] )
				player.SetOneHandedWeaponUsageOff()
				//Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_PlayerRevivedDOF" )

				if ( forceHolster )
					DeployAndEnableWeapons( player )

				//Hide wounded icon for wounded player's allies
				int woundedPlayerEHandle = player.GetEncodedEHandle()
				array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
				foreach ( entity teamPlayer in teamPlayers )
				{
					if ( teamPlayer == player )
						continue
					Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_BLEEDOUT_HideWoundedMarker", woundedPlayerEHandle )
				}
			}
		}
	)

	//if ( bleedoutTime > 0 )
	//	StatusEffect_AddTimed( player, eStatusEffect.bleedoutDOF, 1.0, bleedoutTime, 0.0 )
		//Remote_CallFunction_NonReplay( player, "ServerCallback_BLEEDOUT_StartDyingDOF", bleedoutTime )

	//Show wounded icon for wounded player's allies
	int woundedPlayerEHandle = player.GetEncodedEHandle()
	array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
	foreach ( entity teamPlayer in teamPlayers )
	{
		if ( teamPlayer == player )
			continue

		Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_BLEEDOUT_ShowWoundedMarker", woundedPlayerEHandle, Time(), Time() + bleedoutTime )
	}

	if ( bleedoutTime > 0 )
		wait bleedoutTime
	else
		WaitForever()
	
	if( Bleedout_IsPlayerGettingFirstAid( player ) )
		waitthread Bleedout_OverTimeFirstAid( player )
	if( player.ContextAction_IsActive() )
		waitthread Bleedout_OverTimeAnimation( player )

	if( IsAlive( player ) )
		PlayerDiesFromBleedout( player, file.lastAttacker[ player ] )
}

void function EnablePlayerRes( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_OnStartDying" )
	player.EndSignal( "BleedOut_OnRevive" )

	Highlight_SetFriendlyHighlight( player, "interact_object_los_line" )

	if ( IsPilotEliminationBased() )
		SetPlayerEliminated( player )

	OnThreadEnd(
	function() : ( player )
		{
			if ( IsValid( player ) )
			{
				player.UnsetUsable()
				Highlight_ClearFriendlyHighlight( player )
			}
		}
	)

	while ( true )
	{
		//If the player is not currently being treated or is self healing. (Team healing should always override self-healing)
		if ( !Bleedout_IsPlayerGettingFirstAid( player ) || Bleedout_IsPlayerSelfHealing( player ) )
		{
			player.SetUsableByGroup( "friendlies pilot" )
			player.SetUsePrompts( "#BLEEDOUT_USE_TEAMMATE_RES", "#BLEEDOUT_USE_TEAMMATE_RES_PC" )

			if( file.executingBleedingEnabled )
				thread Bleedout_BecomeExecutionTarget( player )
			entity playerHealer = expect entity ( player.WaitSignal( "OnPlayerUse" ).player )
			player.UnsetUsable()

			/* // tryed to adjust, not using right now
			entity playerHealer = expect entity ( player.WaitSignal( "OnPlayerUse", "BleedOut_OnStartReviving" ).player )
			player.UnsetUsable()
			if( Bleedout_IsPlayerSelfHealing( player ) ) // not showing prompts while selfres
			{
				WaitFrame()
				continue
			}
			*/

			//Player can only res other players if they are not bleeding out themselves.
			if ( !file.isBleeding[ playerHealer ] && ( !Bleedout_IsPlayerGettingFirstAid( player ) || Bleedout_IsPlayerSelfHealing( player ) ) )
				waitthread PlayerAttemptRes( playerHealer, player )
		}
		else
		{
			WaitFrame()
		}
	}
}

void function EnablePlayerSelfRes( entity player )
{
	Assert( IsNewThread(), "Must be threaded off." )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_OnStartDying" )
	player.EndSignal( "BleedOut_OnRevive" )

	while ( true )
	{
		if (  !Bleedout_IsPlayerGettingFirstAid( player ) )
			MessageToPlayer( player, eEventNotifications.BLEEDOUT_SelfHealPrompt )

		if ( player.UseButtonPressed() && !Bleedout_IsPlayerGettingFirstAid( player ) )
		{
			MessageToPlayer( player, eEventNotifications.Clear )
			waitthread PlayerAttemptRes( player, player )
		}

		WaitFrame()
	}
}

void function PlayerAttemptRes( entity playerHealer, entity playerToRes )
{
	Assert( IsNewThread(), "Must be threaded off." )
	playerToRes.Signal( "Bleedout_PlayerAttemptRes" ) // so teammates can interrupt selfRes
	//playerToRes.Signal( "Bleedout_OnStartReviving" ) // not using right now, needs untyped
	playerToRes.EndSignal( "OnDeath" )
	playerToRes.EndSignal( "OnDestroy" )
	playerToRes.EndSignal( "Bleedout_PlayerAttemptRes" )
	playerHealer.EndSignal( "OnDeath" )
	playerHealer.EndSignal( "OnDestroy" )
	playerHealer.EndSignal( "OnContinousUseStopped" )

	if( Bleedout_IsPlayerSelfHealing( playerToRes ) )
		WaitFrame() // do a extra wait if player was selfResing, this means a friendly is interupting their selfRes

	bool isSelfRes = playerHealer == playerToRes // different check, but works better

	string healerTitle = playerHealer.GetTitle()
	string playerTitle = playerToRes.GetTitle()

	if( !isSelfRes )
	{
		EmitSoundOnEntityOnlyToPlayer( playerToRes, playerHealer, "pilot_healthpack_small_healing" )
		EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_small_healing" )
		playerHealer.SetTitle( "#BLEEDOUT_APPLYING_FIRST_AID" )
		playerToRes.SetTitle( "#BLEEDOUT_RECIEVING_FIRST_AID" )
	}
	else
	{
		EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_large_healing" )
		playerToRes.SetTitle( "#BLEEDOUT_APPLYING_FIRST_AID" )
	}

	if( !isSelfRes )
		HolsterAndDisableWeapons( playerHealer )

	playerHealer.MovementDisable()
	playerToRes.MovementDisable()

	float firstAidTime = playerHealer == playerToRes ? Bleedout_GetFirstAidTimeSelf() : Bleedout_GetFirstAidTime()
	float firstAidHealPercent = Bleedout_GetFirstAidHealPercent()

	float endTime = Time() + firstAidTime

	int playerEHandle = playerToRes.GetEncodedEHandle()
	int healerEHandle = playerHealer.GetEncodedEHandle()
	int attemptID = GetNewFirstAidAttemptID()

	Remote_CallFunction_NonReplay( playerToRes, "ServerCallback_BLEEDOUT_StartFirstAidProgressBar", endTime, playerEHandle, healerEHandle, attemptID )
	Remote_CallFunction_NonReplay( playerHealer, "ServerCallback_BLEEDOUT_StartFirstAidProgressBar", endTime, playerEHandle, healerEHandle, attemptID )
	file.IsGettingFirstAidFrom[ playerToRes ] = playerHealer

	OnThreadEnd(
	function() : ( playerHealer, playerToRes, attemptID, isSelfRes, healerTitle, playerTitle )
		{
			if ( IsValid( playerHealer ) )
			{
				if ( IsValid( playerToRes ) )
				{
					if( !isSelfRes )
					{
						if( file.isBleeding[ playerToRes ] ) // interrupted revive
							EmitSoundOnEntityOnlyToPlayer( playerToRes, playerHealer, "pilot_healthpack_drop" )
						else
							EmitSoundOnEntityOnlyToPlayer( playerToRes, playerHealer, "pilot_healthpack_small_healing_end" )
					}
				}
				if( !isSelfRes )
				{
					DeployAndEnableWeapons( playerHealer )
					playerHealer.SetTitle( healerTitle )
				}
				playerHealer.MovementEnable()
				Remote_CallFunction_NonReplay( playerHealer, "ServerCallback_BLEEDOUT_StopFirstAidProgressBar", attemptID )
			
			}

			if ( IsValid( playerToRes ) )
			{
				file.IsGettingFirstAidFrom[ playerToRes ] = null
				playerToRes.MovementEnable()
				Remote_CallFunction_NonReplay( playerToRes, "ServerCallback_BLEEDOUT_StopFirstAidProgressBar", attemptID )
				StopSoundOnEntity( playerToRes, "pilot_healthpack_small_healing" )
				StopSoundOnEntity( playerToRes, "pilot_healthpack_large_healing" )

				if( file.isBleeding[ playerToRes ] ) // interrupted revive
				{
					playerToRes.SetTitle( playerTitle )
					if( isSelfRes )
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_drop" )
					else
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_drop" )
				}
				else
				{
					if( isSelfRes )
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_large_healing_end" )
					else
						EmitSoundOnEntityOnlyToPlayer( playerToRes, playerToRes, "pilot_healthpack_small_healing_end" )
				}
			}
		}
	)
#if BLEEDOUT_DEBUG
	waitthread DEBUG_AutoUsePress( playerHealer, playerToRes, firstAidTime )
#else
	waitthread TrackContinuousUse( playerHealer, playerToRes, firstAidTime, true )
#endif

	file.isBleeding[ playerToRes ] = false
	file.lastAttacker[ playerToRes ] = svGlobal.worldspawn
	if ( IsPilotEliminationBased() )
		ClearPlayerEliminated( playerToRes )

	// this should done before callbacks since it triggers a "OnClassChange"
	Bleedout_EnableWallrunAndDoubleJump( playerToRes )

	//Heal player health
	playerToRes.SetHealth( playerToRes.GetMaxHealth() * firstAidHealPercent )

	foreach( void functionref( entity, entity ) callbackFunc in file.Callbacks_OnPlayerGiveFirstAid )
	{
		//if ( IsValid( callbackFunc ) )
		//{
			//Do not run this callback if player is self healing.
		//	if ( playerHealer != playerToRes )
		//		callbackFunc( playerHealer )
		//}
		callbackFunc( playerToRes, playerHealer )
	}

	playerToRes.Signal( "BleedOut_OnRevive" )

}

void function BloodTrail( entity player )
{
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	player.EndSignal( "OnDeath")

	while ( true )
	{
		float interval = RandomFloatRange( 0.25, 0.5 )
		PlayFXOnEntity( FX_BLOODTRAIL, player )
		wait interval
	}
}

void function PlayerDiesFromBleedout( entity player, entity attacker )
{
	if ( IsValid( attacker ) )
	{
		player.Die( attacker, attacker, { damageSourceId = eDamageSourceId.bleedout } )
		//player.BecomeRagdoll( Vector(0,0,0), false )
	}
	else
	{
		player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { damageSourceId = eDamageSourceId.bleedout } )
		//player.BecomeRagdoll( Vector(0,0,0), false )
	}


}

//This function checks to see if all players on a team are dead or bleeding out.
//If all the players are dead/bleeding out, it kills the surviving team players.
// use this to better support killshot sound
//void function CheckForTeamBleedout( int team )
bool function CheckForTeamBleedout( entity player )
{
	array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
	foreach ( entity teamPlayer in teamPlayers )
	{
		if( teamPlayer == player )
			continue
		if ( IsAlive( teamPlayer ) && !file.isBleeding[ teamPlayer ] )
			return false
	}

	//All players on team are bleeding out
	foreach ( entity teamPlayer in teamPlayers )
	{
		if ( IsAlive( teamPlayer ) )
			PlayerDiesFromBleedout( teamPlayer, file.lastAttacker[ teamPlayer ] )
	}
	return true
}

bool function Bleedout_ShouldAIMissBleedingPlayer( entity player )
{
	//If the player is not bleeding
	if ( !file.isBleeding[ player ] )
		return false

	//If the bleedout settings don't affect AI accuracy.
	if ( !Bleedout_ShouldAIMissPlayer() )
		return false

	return true
}

//bool function Bleedout_IsPlayerGettingFirstAid( entity player ) // function name adjustment
bool function Bleedout_IsPlayerGettingFirstAid( entity player )
{
	return file.IsGettingFirstAidFrom[ player ] != null
}

//bool function IsPlayerSelfHealing( entity player ) // function name adjustment
bool function Bleedout_IsPlayerSelfHealing( entity player )
{
	return file.IsGettingFirstAidFrom[ player ] == player
}

//////////////
//Utilities
//////////////
void function TrackContinuousUse( entity player, entity useTarget, float useTime, bool doRequireUseButtonHeld )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	useTarget.EndSignal( "OnDeath" )
	useTarget.EndSignal( "OnDestroy" )

	table result = {}
	result.success <- false

	float maxDist2 = DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) + BLEEDOUT_MAX_USE_DIST2_MOD

	OnThreadEnd
	(
		function() : ( player, result )
		{
			if ( !result.success )
			{
				player.Signal( "OnContinousUseStopped" )
			}
		}
	)

	float startTime = Time()
	while ( Time() < startTime + useTime && (!doRequireUseButtonHeld || player.UseButtonPressed()) && !player.IsPhaseShifted() && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
		WaitFrame()

	if ( ( !doRequireUseButtonHeld || player.UseButtonPressed() ) && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2  )
		result.success = true
}

void function DEBUG_AutoUsePress( entity player, entity useTarget, float useTime )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	useTarget.EndSignal( "OnDeath" )
	useTarget.EndSignal( "OnDestroy" )

	table result = {}
	result.success <- false

	float maxDist2 = DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) + BLEEDOUT_MAX_USE_DIST2_MOD

	OnThreadEnd
	(
		function() : ( player, result )
		{
			if ( !result.success )
			{
				player.Signal( "OnContinousUseStopped" )
			}
		}
	)

	float startTime = Time()
	while ( Time() < startTime + useTime && DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
		WaitFrame()

	if ( DistanceSqr( player.GetOrigin(), useTarget.GetOrigin() ) <= maxDist2 )
		result.success = true
}

int function GetNewFirstAidAttemptID()
{
	file.firstAidAttemptID += 1
	return file.firstAidAttemptID
}

// modified function
void function Bleedout_EnableExecutingBleeingPlayer( bool enable )
{
	file.executingBleedingEnabled = enable
}

bool function Bleedout_IsPlayerBleeding( entity player )
{
	return file.isBleeding[player]
}

// no idea
//bool function Bleedout_IsRevivingFriendly( entity player )
//{
//	return 
//}

void function Bleedout_OverTimeFirstAid( entity player )		
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	while( true )
	{
		WaitFrame()
		if( Bleedout_IsPlayerGettingFirstAid( player ) )
			continue
		else
			break
	}
}

void function Bleedout_PlayerDownedSound( entity victim, entity attacker )
{
	if( attacker.IsPlayer() )
	{
		if( victim.IsMechanical() )
		{
			//if( attacker != victim )
			//	EmitSoundOnEntityOnlyToPlayer( victim, attacker, "android_bulletimpact_killshot_1p_vs_3p" )
			EmitSoundOnEntityExceptToPlayer( victim, attacker, "android_bulletimpact_killshot_3p_vs_3p" )
		}
		else
		{
			//if( attacker != victim )
			//	EmitSoundOnEntityOnlyToPlayer( victim, attacker, "flesh_bulletimpact_killshot_1p_vs_3p" )
			EmitSoundOnEntityExceptToPlayer( victim, attacker, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
		}
	}
	else
	{
		if( victim.IsMechanical() )
			EmitSoundOnEntity( victim, "android_bulletimpact_killshot_3p_vs_3p" )
		else
			EmitSoundOnEntity( victim, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
	}
}

void function Bleedout_PlayerDownedObit( entity ent, entity attacker, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	// trigger_hurt is no longer networked, so the "attacker" fails to display obituaries
	if ( attacker )
	{
		string attackerClassname = attacker.GetClassName()

		if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
			attacker = GetEntByIndex( 0 ) // worldspawn
	}

	int attackerEHandle = attacker ? attacker.GetEncodedEHandle() : -1

	int victimEHandle = ent.GetEncodedEHandle()
	int scriptDamageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( scriptDamageType & DF_VORTEX_REFIRE )
		damageSourceId = eDamageSourceId.mp_titanweapon_vortex_shield

	if ( IsValidHeadShot( damageInfo, ent ) )
		scriptDamageType = scriptDamageType | DF_HEADSHOT
	else
		scriptDamageType = scriptDamageType & (~DF_HEADSHOT)

	foreach ( entity player in GetPlayerArray() )
	{
		if( player != ent )
			Remote_CallFunction_NonReplay( player, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	}
}

void function Bleedout_DeathProtection( entity player )
{
	player.SetInvulnerable()
	wait 1.05
	player.ClearInvulnerable()
}

void function Bleedout_PlayerSlidePrevention( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	//bool lastFrameSlide // for checks
	while( true )
	{
		WaitFrame()
		if( player.IsSliding() && player.IsOnGround() ) // sometimes sliding off a roof will remain slide state, do a check
		{
			player.SetVelocity( < 0,0,0 > )
		//	lastFrameSlide = true
		//	continue
		}
		//if( lastFrameSlide && !player.IsOnGround() ) // prevent player being stopped midair
		//	player.SetVelocity( < 0,0,100 > )
		//lastFrameSlide = false
	}
}

void function Bleedout_DiableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	if( !settingMods.contains( "disable_wallrun" ) )
		settingMods.append( "disable_wallrun" )
	if( !settingMods.contains( "disable_doublejump" ) )
		settingMods.append( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_EnableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	settingMods.removebyvalue( "disable_wallrun" )
	settingMods.removebyvalue( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_PlayerHolsterWeapon( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	HolsterAndDisableWeapons( player )
	while( true )
	{
		player.HolsterWeapon()
		player.Server_TurnOffhandWeaponsDisabledOn()
		WaitFrame()
	}
}

void function Bleedout_PlayerForceStand( entity player )
{
	player.ForceStand()
	wait 0.2
	if( IsValid( player ) )
		player.UnforceStand()
}

void function Bleedout_EnemySpottingHighlight( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			Highlight_ClearEnemyHighlight( player )
		}
	)

	while( true )
	{
		Highlight_SetEnemyHighlight( player, "sp_enemy_pilot" )
		player.Highlight_SetParam( 2, 0, < 2,0,0 > )
		WaitFrame()
	}
}

void function Bleedout_BecomeExecutionTarget( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	entity hitBox = CreateHitboxEntityForPlayer( player )
	hitBox.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( hitBox )
		{
			//print( "hitBox Think End" )
			if( IsValid( hitBox ) )
				hitBox.Destroy()
		}
	)

	while( true )
	{
		// temp unsetUsable() when player getting firstaid by friendlies
		if( Bleedout_IsPlayerGettingFirstAid( player ) && !Bleedout_IsPlayerSelfHealing( player ) )
		{	
			hitBox.UnsetUsable()
			//print( "hitBox being UnsetUsable()" )
		}
		else if( !player.ContextAction_IsActive() ) // assuming this is player being executing, wait for it
		{	
			hitBox.SetUsable()
			//print( "hitBox being SetUsable()" )
		}

		// defensive fixs
		if( !player.ContextAction_IsActive() ) 
		{
			hitBox.SetUsable()
			//print( "hitBox being SetUsable()" )
		}
		else
		{
			hitBox.UnsetUsable()
			//print( "hitBox being UnsetUsable()" )
		}
		WaitFrame()
	}
}

entity function CreateHitboxEntityForPlayer( entity player )
{
	entity hitBox = CreatePropScript( BLEEDOUT_EXECUTION_HITBOX_MODEL )
	hitBox.SetParent( player, "CHESTFOCUS" )
	//hitBox.SetOrigin( < 30, 0, 0 > )
	//hitBox.SetLocalAngles( < 90, -90, 0 > )
	hitBox.SetTakeDamageType( DAMAGE_NO )
	SetTeam( hitBox, player.GetTeam() )
	SetObjectCanBeMeleed( hitBox, false )
	//hitBox.kv.modelscale = 0.1
	hitBox.kv.solid = SOLID_VPHYSICS
	hitBox.Hide()
	
	hitBox.SetOwner( player )
	
	hitBox.SetUsable()
    hitBox.SetUsableByGroup( "enemies pilot" )
    hitBox.SetUsePrompts( "在身後按住 %use% 以進行處決", "在身後按下 %use% 以進行處決" )

    AddCallback_OnUseEntity( hitBox, ExecuteHitboxOwner )
	return hitBox
}

var function ExecuteHitboxOwner( var hitBox, var player )
{
	expect entity( player )
	expect entity( hitBox )
	thread ExecuteHitboxOwner_Threaded( hitBox, player )
}

void function ExecuteHitboxOwner_Threaded( entity hitBox, entity player )
{
	entity owner = hitBox.GetOwner()
	hitBox.UnsetUsable()

	SyncedMeleeChooser ornull actions = GetSyncedMeleeChooserForPlayerVsTarget( player, owner )
	if( actions == null )
		return
	expect SyncedMeleeChooser( actions )
	SyncedMelee ornull action = FindBestSyncedMelee( player, owner, actions )
	if( action == null )
		return
	expect SyncedMelee( action )
	waitthread MeleeThread_PilotVsEnemy( action, player, owner )
	
	if( IsValid( hitBox ) )
	{
		if( !IsAlive( owner ) ) // owner died
			hitBox.Destroy()
		else
			hitBox.SetUsable() // reset usable
	}
}

void function Bleedout_OverTimeAnimation( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	while( true )
	{
		WaitFrame()
		if( player.ContextAction_IsActive() )
			continue
		else
			break
	}
}

void function Bleedout_HealthRegenThink( entity player )
{
    player.EndSignal( "OnDestroy" )
	player.Signal( "BleedoutHealthRegenThink" )
	player.Signal( "StopHealthRegenThink" ) // end normal health regen in _health_regen.gnut
	player.EndSignal( "BleedoutHealthRegenThink" )
	player.EndSignal( "StopHealthRegenThink" )

	float healthRegenStartDelay = file.bleedoutHealthRegenDelay

	while ( IsValid( player ) )
	{
		//print( "Bleedout Health Regen Think" )
		wait( HEALTH_REGEN_TICK_TIME )

		if ( !IsAlive( player ) )
			continue

		if ( !IsPilot( player ) )
			continue

		if ( shGlobal.proto_pilotHealthRegenDisabled )
			continue

		float healthRegenRate = file.bleedoutHealthRegenRate	// health regen per tick

		if ( player.GetHealth() == player.GetMaxHealth() )
			continue

		// No regen during phase shift
		if ( player.IsPhaseShifted() )
			continue

		// no regen during bleeding out
		if( file.isBleeding[ player ] )
			continue

		if ( Time() - player.p.lastDamageTime < healthRegenStartDelay )
		{
			continue
		}

		player.SetHealth( min( player.GetMaxHealth(), player.GetHealth() + healthRegenRate ) )
		if ( player.GetHealth() == player.GetMaxHealth() )
		{
			ClearRecentDamageHistory( player )
			ClearLastAttacker( player )
		}
	}
}

void function Bleedout_SetHealthRegenRate( float rate )
{
	file.bleedoutHealthRegenRate = rate
}

void function Bleedout_SetHealthRegenDelay( float delay )
{
	file.bleedoutHealthRegenDelay = delay
}