untyped

global function ClassicRodeo_InitPlaylistVars

#if SERVER
global function CreateClassicRodeoWeakpoint
#endif

const asset RODEO_WEAKPOINT_HITBOX_MODEL = $"models/Weapons/ammoboxes/backpack_single.mdl"

void function ClassicRodeo_InitPlaylistVars()
{
	AddPrivateMatchModeSettingEnum( "#MODE_SETTING_CATEGORY_TITAN", "classic_rodeo", [ "#SETTING_DISABLED", "#SETTING_ENABLED" ], "0" )
}

#if SERVER
entity function CreateClassicRodeoWeakpoint( entity player, entity titan )
{
	entity weakpoint = CreatePropScript( RODEO_WEAKPOINT_HITBOX_MODEL )
	weakpoint.SetParent( titan, "RODEO_BATTERY" )
	weakpoint.SetLocalAngles( < 90, -90, 0 > )
	weakpoint.SetTakeDamageType( DAMAGE_YES )
	SetTeam( weakpoint, TEAM_UNASSIGNED )
	SetObjectCanBeMeleed( weakpoint, false )
	weakpoint.kv.solid = 6
	weakpoint.Hide()
	
	// stryder ones don't really work in the default position, so change it
	// note: stryders are way too easy to hit because of this lol so possibly fuck with it
	if ( GetSoulTitanSubClass( titan.GetTitanSoul() ) == "stryder" )
		weakpoint.SetLocalOrigin( < 0, 4, -4 > )
	
	weakpoint.s.pilot <- player
	weakpoint.s.titan <- titan
	
	AddEntityCallback_OnDamaged( weakpoint, OnRodeoWeakpointDamaged )
}

void function OnRodeoWeakpointDamaged( entity weakpoint, var damageInfo )
{	
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	entity titan = attacker.GetParent()
	float damageAmount = DamageInfo_GetDamage( damageInfo )
	DamageInfo_SetDamage( damageInfo, 0 ) // make sure weakpoint ent doesn't die ever

	if ( attacker != weakpoint.s.pilot || titan != weakpoint.s.titan )
		return
		
	// figure out damage to deal to titan
	entity attackerWeapon = DamageInfo_GetWeapon( damageInfo )
	if ( !IsValid( attackerWeapon ) )
		attackerWeapon = attacker.GetActiveWeapon()
	
	// most weapons in ttf2 don't have damage_rodeo, let's use it's damage_near_value_titanarmor
	string weaponName = attackerWeapon.GetWeaponClassName()
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	bool shouldMultiplierDamage = true
	int rodeoDamage = attackerWeapon.GetWeaponSettingInt( eWeaponVar.damage_near_value_titanarmor )
	bool canNormallyDamage = attackerWeapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
	if( canNormallyDamage )
		shouldMultiplierDamage = false
	float damageScale = attackerWeapon.GetWeaponSettingFloat( eWeaponVar.critical_hit_damage_scale )

	if( IsValid( inflictor ) )
	{
		if( inflictor.IsProjectile() )
		{
			//print( "inflictor is projectile!" )
			if( inflictor.GetClassName() == "grenade" )
			{
				//print( "damaged by grenade!" )
				shouldMultiplierDamage = false
			}
		}
		if( inflictor.GetClassName() == "script_mover_lightweight" ) // hardcoded, assuming this is ballLightning in vanilla
		{
			//print( "damaged by arcball!" )
			rodeoDamage = int( inflictor.e.ballLightningData.damage )
			shouldMultiplierDamage = false
		}
	}
	else if( weaponName == "mp_weapon_grenade_electric_smoke" ) // hardcoded here
	{
		rodeoDamage = 300 // electric smoke grenade's damage per tick
		shouldMultiplierDamage = false
	}
	if( shouldMultiplierDamage )
		rodeoDamage = int( rodeoDamage * damageScale * 1.5 )

	// hitmarker
	attacker.NotifyDidDamage( weakpoint, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamagePosition( damageInfo ), DamageInfo_GetCustomDamageType( damageInfo ) | DF_CRITICAL, rodeoDamage, DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )
	// damage titan, make sure DF_BYPASS_SHIELD	is a thing for proper behaviour
	titan.TakeDamage( rodeoDamage, attacker, attackerWeapon, { damageSourceId = eDamageSourceId.rodeo, scriptType = DamageInfo_GetCustomDamageType( damageInfo ) | DF_BYPASS_SHIELD } )
}
#endif