untyped
global function Pilot_Shield_Battery_Init

global function SetPilotBatteryUsageAllowed
global function SetShieldBatteryNoLimit
global function IsShieldBatteryEnabled

const float SHIELD_BATTERY_USE_TIME = 3
const int SHIELD_BATTERY_REGEN_AMOUNT = 50

const float AMPED_SHIELD_BATTERY_USE_TIME = 5

struct
{
    bool canUseShiledBattery = false
    bool noLimitBattery = false // let player use batteries whenever they want, for fun
} file

void function Pilot_Shield_Battery_Init()
{
    RegisterSignal( "StartContinuousUseThink" )
    RegisterSignal( "StartButtonCancelCheck" )
    RegisterSignal( "StopUseShieldBattery" )
    RegisterSignal( "DoneUseShieldBattery" )
    // register things for ingame script
    if( GetGameState() == eGameState.Playing )
    {
        foreach( entity player in GetPlayerArray() )
            OnClientConnected( player )
    }
    AddCallback_OnClientConnected( OnClientConnected )
}

void function OnClientConnected( entity player )
{
    player.s.shieldBatteryEndFunction <- false
    player.s.usingShieldBattery <- false
    AddPlayerHeldButtonEventCallback( player, IN_USE, TryUseShieldBattery, 0.5 )
    AddPlayerHeldButtonEventCallback( player, IN_USE_AND_RELOAD, TryUseShieldBattery, 1.0 )
}

void function TryUseShieldBattery( entity player )
{
    thread TryUseShieldBattery_Threaded( player )
}

void function TryUseShieldBattery_Threaded( entity player )
{
    if( !file.canUseShiledBattery )
        return
    if( expect bool( player.s.usingShieldBattery ) )
        return
    if( !( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) ) )
        return
    if( !file.noLimitBattery && ( player.GetShieldHealthMax() < 1 || player.GetShieldHealth() == player.GetShieldHealthMax() ) )
    {
        SendHudMessage( player, "护盾已满", -1, -0.3, 255, 255, 100, 255, 0, 1, 0 )
        return
    }

    //thread ContinuousUseThink( player )
    player.EndSignal( "StopUseShieldBattery" )
    player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnDeath" )

    entity battery = GetBatteryOnBack( player )
    if( !IsValid( battery ) )
    {
        SendHudMessage( player, "未持有电池", -1, -0.3, 255, 255, 100, 255, 0, 1, 0 )
        return
    }

    battery.EndSignal( "OnDestroy" )
    player.s.shieldBatteryEndFunction = true
    player.s.usingShieldBattery = true

    int statusEffectHandle = StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.4 )

    OnThreadEnd(
        function(): ( player, battery, statusEffectHandle )
        {
            //print( "Reached here! 1" )
            if( !IsValid( player ) )
                return
            player.s.usingShieldBattery = false
            player.DeployWeapon()
            player.Server_TurnOffhandWeaponsDisabledOff()
            StopSoundOnEntity( player, "Weapon_EnergySyphon_Charge_1P" )
            //StopSoundOnEntity( player, "Weapon_EnergySyphon_Charge_3P" )
            if( statusEffectHandle != -1 )
                StatusEffect_Stop( player, statusEffectHandle )
            
            if( !( expect bool( player.s.shieldBatteryEndFunction ) ) )
                return
            if( IsAlive( player ) )
            {
                //print( "Reached here! 5" )
                entity newestBattery = Rodeo_TakeBatteryAwayFromPilot( player )
                if( IsValid( battery ) && IsValid( newestBattery ) )
                {
                    if( battery == newestBattery )
                        Rodeo_PilotPicksUpBattery( player, battery )
                    else
                        Rodeo_PilotPicksUpBattery( player, newestBattery )
                    SendHudMessage( player, "取消使用护盾电池", -1, -0.3, 255, 255, 100, 255, 0, 1, 0 )
                }
            }
        }
    )
    bool isAmped = IsAmpedBattery( battery )
    float useTime = SHIELD_BATTERY_USE_TIME
    if( isAmped )
        useTime = AMPED_SHIELD_BATTERY_USE_TIME
    thread ButtonCancelCheck( player, useTime + 0.6 )

    player.HolsterWeapon()
    player.Server_TurnOffhandWeaponsDisabledOn()
    wait 0.6 // wait for player hoster their weapon
    battery.ClearParent()
    battery.SetParent( player, "PROPGUN" )
    battery.SetAngles( < 0,90,90 > )
    EmitSoundOnEntityOnlyToPlayer( player, player, "Weapon_EnergySyphon_Charge_1P" )
    //EmitSoundOnEntityExceptToPlayer( player, player, "Weapon_EnergySyphon_Charge_3P" ) // can be too noisy

    float startTime = Time()
    while( startTime + useTime > Time() )
    {
        player.HolsterWeapon() // defensive fix
        player.Server_TurnOffhandWeaponsDisabledOn()
        if( isAmped )
            SendHudMessage( player, "正在使用强力护盾电池 [ " + CreateHudProgressBarThroughTime( Time(), startTime, useTime ) + " ]\n(按下开火以取消)", -1, -0.3, 255, 255, 100, 255, 0, 0.2, 0 )
        else
            SendHudMessage( player, "正在使用护盾电池 [ " + CreateHudProgressBarThroughTime( Time(), startTime, useTime ) + " ]\n(按下开火以取消)", -1, -0.3, 255, 255, 100, 255, 0, 0.2, 0 )
        WaitFrame()
    }

    // done using
    player.s.shieldBatteryEndFunction = false
    player.Signal( "DoneUseShieldBattery" )

    int currentShieldHealth = player.GetShieldHealth()
    int shieldToRestore = int( min( player.GetShieldHealthMax() - currentShieldHealth, SHIELD_BATTERY_REGEN_AMOUNT ) )
    if( isAmped )
        shieldToRestore = player.GetShieldHealthMax() - currentShieldHealth
    
    player.SetShieldHealth( min( player.GetShieldHealthMax(), currentShieldHealth + shieldToRestore ) )
    //print( "Reached here! 2" )

    entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( $"P_xo_armor_body_CP" ), FX_PATTACH_POINT_FOLLOW, player.LookupAttachment( "CHESTFOCUS" ) )
    //EmitSoundOnEntityOnlyToPlayer( player, player, "UI_TitanBattery_Pilot_Give_TitanBattery" )

    if( isAmped )
        EffectSetControlPointVector( shieldFXHandle, 1, < 255, 165, 0 > )
    else
        EffectSetControlPointVector( shieldFXHandle, 1, < 30, 255, 100 > )
    //print( "Reached here! 3" )

    SendHudMessage( player, "已回复" + string(shieldToRestore) + "点护盾! ", -1, -0.3, 255, 255, 100, 255, 0, 2, 0 )

    MessageToPlayer( player, eEventNotifications.Rodeo_PilotAppliedBatteryToYou, player, isAmped )

    entity newestBattery = Rodeo_TakeBatteryAwayFromPilot( player )
    if( IsValid( battery ) && IsValid( newestBattery ) )
    {
        //print( "Reached here! 4" )
        if( battery == newestBattery )
            newestBattery.Destroy()
    }
}

string function CreateHudProgressBarThroughTime( float nowGlobalTime, float startGlobalTime, float totalTime )
{
    int barLength = 20
    float progress = ( nowGlobalTime - startGlobalTime ) / totalTime
    //print( "Total progress is: " + string( progress ) )
    int numToReplace = int( barLength * progress )
    //print( "numToReplace is: " + string( numToReplace ) )
    string progessBar
    for( int i = 0; i < barLength; i++ )
    {
        if( i <= numToReplace )
            progessBar += "/"
        else
            progessBar += "-"
    }
    string tempBar = progessBar
    return tempBar
}

void function ContinuousUseThink( entity player )
{
    player.Signal( "StartContinuousUseThink" )
    player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnDeath" )
    player.EndSignal( "StartContinuousUseThink" )
    player.EndSignal( "DoneUseShieldBattery" )
    while( true )
    {
        //print( "Player Holding IN_USE" )
        if( !( player.IsInputCommandHeld( IN_USE ) || player.IsInputCommandHeld( IN_USE_AND_RELOAD ) ) )
        {
            player.Signal( "StopUseShieldBattery" )
            break
        }
        WaitFrame()
    }
}

void function ButtonCancelCheck( entity player, float maxTime )
{
    player.Signal( "StartButtonCancelCheck" )
    player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnDeath" )
    player.EndSignal( "StartButtonCancelCheck" )
    player.EndSignal( "DoneUseShieldBattery" )
    player.EndSignal( "StopUseShieldBattery" )

    OnThreadEnd(
        function(): ( player )
        {
            if( IsValid( player ) )
                RemoveButtonPressedPlayerInputCallback( player, IN_ATTACK, InterruptShieldBattery )
        }
    )

    AddButtonPressedPlayerInputCallback( player, IN_ATTACK, InterruptShieldBattery )
    wait maxTime
}

void function InterruptShieldBattery( entity player )
{
    player.Signal( "StopUseShieldBattery" )
}

void function SetPilotBatteryUsageAllowed( bool allowed )
{
    file.canUseShiledBattery = allowed
}

void function SetShieldBatteryNoLimit( bool nolimit )
{
    file.noLimitBattery = nolimit
}

bool function IsShieldBatteryEnabled()
{
    return file.canUseShiledBattery
}